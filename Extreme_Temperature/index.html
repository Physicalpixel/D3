<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />


</body>
<style>
    @import url('https://fonts.googleapis.com/css?family=Proxima+Nova');

    body {
        overflow-x: hidden;
        font-family: 'proxima-nova', sans-serif;
    }
    .heading {
        color:#f5b041;
       position: absolute;
       margin-top:0;
       top:15px;
       left:100px;
       font-size:28px;
       font-weight: bold;
        font-family: 'proxima-nova', sans-serif;
    }
    .svg {
        position:absolute;
        top:105px;
    }
    #slider-time{
        position: absolute;
       top:580px;
       color: #f5b041;
    }

    .state-borders {
        fill: none;
        stroke-width: 0.7px;
        stroke-linejoin: round;
        stroke-linecap: round;
        pointer-events: none;
    }

    #tooltip {
        margin-top: 20px;
        color: black;
        font-size: 14px;
    }

   
   
    
</style>
<div class="top">
    <p class="heading">Temperature anomalies recorded between<br> 1880 and 2016
    </p>
    <div>
        <div id="slider-time"></div>
    </div>

</div>
<div class="svg">
    <svg width="1000" height="500"></svg>
</div>

<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://d3js.org/topojson.v2.min.js"></script>
<script src="https://unpkg.com/d3-simple-slider"></script>
<script>
    var svg = d3.select("body").select("svg")

    Promise.all([
        d3.json("https://raw.githubusercontent.com/Physicalpixel/D3/main/Extreme_Temperature/states.geojson"),
        d3.csv("https://raw.githubusercontent.com/Physicalpixel/D3/main/Extreme_Temperature/extreme1.csv")
    ])
        .then(showData)

    function showData([data,temp]) {

        let year_keys = d3.map(temp,d => d.year).keys()
        let year = year_keys.sort(d3.ascending)


        var projection = d3.geoMercator()
            .scale(330)

        var path = d3.geoPath()
            .projection(projection);

        svg.selectAll("path")
            .data(data.features)
            .enter()
            .append("path")
            .attr("d",d => path(d))
            .attr("stroke","white")
            .attr("width",10)
            .attr("height",10)
            .attr("fill","grey")
            .attr("opacity", 0.5)
            .attr("transform","translate(600, 350) rotate(0)")

       

            let tooltip = d3.select('body')
            .append('div')
            .attr('id', 'tooltip')
            .style("position", "absolute")
            .style('opacity', 0)
            .style('width', 100)
            .style('height', 100)
            .style("background-color", "white")
            .style("border-radius", "5px")
            .style("padding", "10px")
           

        svg.selectAll("polygon")
            .data(temp)
            .enter()
            .append("polygon")
            .attr("points",function (d) {
                var points = tempCoords(d)
                //console.log(points)
                return points
            })
            .attr("stroke","red")
            .attr("stroke-width",0.2)
            .attr("transform","translate(600, 350) rotate(0)")
            .style("opacity",0)
            .on("mouseover",function (d) {
                tooltip.transition()
                    .duration(200)
                    .style("opacity",0.9);
                tooltip.html("Anomaly:" + d.temp_anom + "&#8451;")
                    .style("left",(d3.event.pageX + 10) + "px")
                    .style("top",(d3.event.pageY - 28) + "px");
            })
            .on("mouseout",function (d) {
                tooltip.transition()
                    .style("opacity",0);
            });


        function tempCoords(d) {
            var cx = projection([+d.Longitude,+d.Latitude])[0]
            var cy = projection([+d.Longitude,+d.Latitude])[1]
            return [
                [
                    [cx + 1,cy],
                    [cx,cy + 1],
                    [cx + 2,cy + 1],
                    [cx + 1,cy]
                ]
            ]
        }

        svg.selectAll("text")
            .data(temp.filter(function (d) {
                return d.year == 1881
            }))
            .enter()
            .append("text")
            .text(d => d.year)
            .style("fill","grey")
            .style("opacity",0.009)
            .attr("font-size",100)
            .attr("transform","translate(360, 180) rotate(0)")

        max = d3.max(temp,d => +d.temp_anom)
        min = d3.min(temp,d => +d.temp_anom)
        var scale;
        //////////////////////////////////////////////////////////////////////////////  

        var dataTime = d3.range(0,140,6).map(function (d) {
            return new Date(1879 + d,20,4);
        });


        function tempCoords1(d) {

            if (d.temp_anom >= -3 && d.temp_anom < 1) {

                scale = d3.scaleLinear()
                    .domain([-3,1])
                    .range([0.5,1])
            } else if (d.temp_anom >= 1 && d.temp_anom < 2) {

                scale = d3.scaleLinear()
                    .domain([1,2])
                    .range([5,8])
            } else if (d.temp_anom >= 2 && d.temp_anom < 3) {

                scale = d3.scaleLinear()
                    .domain([2,3])
                    .range([10,19])
            } else if (d.temp_anom >= 3 && d.temp_anom < 4) {

                scale = d3.scaleLinear()
                    .domain([3,4])
                    .range([30,40])
            } else if (d.temp_anom >= 4 && d.temp_anom < 8) {

                scale = d3.scaleLinear()
                    .domain([4,8])
                    .range([60,80])
            }
            var cx = projection([+d.Longitude,+d.Latitude])[0]
            var cy = projection([+d.Longitude,+d.Latitude])[1]
            return [
                [
                    [cx + 2,cy - scale(+d.temp_anom)],
                    [cx,cy + 1],
                    [cx + 4,cy + 1],
                    [cx + 2,cy - scale(+d.temp_anom)],
                ]
            ]
        }


        var sliderTime = d3
            .sliderBottom()
            .min(d3.min(dataTime))
            .max(d3.max(dataTime))
            .step(1000 * 60 * 60 * 24 * 365)
            .width(700)
            .tickFormat(d3.timeFormat('%Y'))
            .tickValues(dataTime)
            .default(new Date(1880,10,3))
            .on('onchange',val => {
                var x = d3.timeFormat('%Y')(val)
                console.log(x)
                svg.selectAll("polygon")
                    .style("opacity",0)
                svg.selectAll("polygon")
                    .data(temp.filter(function (d) {
                        return d.year <= x && d.year > x - 15
                    }))
                    .attr("points",function (d) {
                        var points = tempCoords1(d)
                        //console.log(points)
                        return points
                    })
                    .attr("stroke","red")
                    .attr("stroke-width",0.2)
                    .attr("transform","translate(600, 350) rotate(0)")
                    .style("opacity",function (d) {
                        if (d.year == x) {
                            return 1
                        } 
                    })

                //d3.select('p#value-time').text(d3.timeFormat('%Y')(val))
                svg.selectAll("text")
                    .style("opacity",0)
                svg.selectAll("text")
                    .data(x)
                    .text(d => x)
                    .style("fill","#f5b041")
                    .style("opacity",0.5)
                    .attr("font-size",100)
                    .attr("transform","translate(400, 200) rotate(0)")

            });

        var gTime = d3
            .select('div#slider-time')
            .append('svg')
            .attr('width',2000)
            .attr('height',80)
            .append('g')
            .attr('transform','translate(100,30)');

        gTime.call(sliderTime);

    }
</script>

</html>
